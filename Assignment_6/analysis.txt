Nicholas Feanny--naf16b--December 7, 2016

Analysis:

	Reading Input: In my program, the main while loop acts as the overarching loop through the duration of inputs being stored into a string(one line at a time), which is then parsed into a map; So to start the complexity of reading the input is O(n). As each line of the stream is read, it is then iterated through on a character-by-character basis; by reading the individual indices of the string for the length of the string(which is indicted by the inner for loop). Once this loop completes the Complexity of reading input becomes O(n^2). 

	Storing Characters/words/numbers: When i create a word or number, I parse the data of an entire string read in by getline which is then passed in as an argument of the digitPuncWord function. This is a linear process as each individual character is read and stored based on the criteria presented by various conditional statements i.e., isalpha, isdigit, etc. If anything occurs more than once i.e., the key already exists, it's value is incremented by 1. As such it is again, O(n). Transferring these pairs stored in the maps (word, number, character), is also O(n) as the insert function used by the vector (the container being transferred to) in a linear process as the process consists of using an iterator which will point to and then assist in the transfer of data from the map to the vector starting from .begin() to .end().

	Looking up characters/words/numbers: I look up the existence of various keys using the .count() member of the map container. if it returns 1, then that key already exist;This is done for all characters for the exception of the null character. However, for words and numbers, once the pair is created or value is incremented the temporary string is then erased and the parsing of individual indexed characters continues on a "empty string". Because maps are made from binary trees, the look up process is of O(log N). Contrary of an unordered map which is O(1).

	Most frequent list and accessing the pairs: As the program continues, onces the data is stored in the map and has all been parsed, it is then trasnferred to a vector, which is O(n). Once stored into the vector I then use the sort() function which is provided by the algorithms library. This is done on each vector once the data has been transferred. the complexity is NlogN where N is the distance and a given number of swaps of data.
